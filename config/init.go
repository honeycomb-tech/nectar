package config

import (
	"fmt"
	"os"
	"path/filepath"
)

// InitCommand handles the 'init' subcommand to generate a default config file
func InitCommand(configPath string) error {
	// Check if config already exists
	if _, err := os.Stat(configPath); err == nil {
		return fmt.Errorf("config file already exists at %s", configPath)
	}

	// Ensure directory exists
	dir := filepath.Dir(configPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	// Generate default config
	defaultConfig := generateDefaultConfig()

	// Write to file
	if err := os.WriteFile(configPath, []byte(defaultConfig), 0644); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	fmt.Printf("Configuration file created at: %s\n", configPath)
	fmt.Println("Please edit this file to match your environment settings.")
	return nil
}

// generateDefaultConfig returns the default TOML configuration as a string
func generateDefaultConfig() string {
	return `# Nectar Configuration File
# Generated by 'nectar init'
version = "1.0"

[database]
# Database connection string
# For TiDB, use: root:password@tcp(host:port)/database?charset=utf8mb4&parseTime=True
# For HAProxy load balancer: root:password@tcp(127.0.0.1:3999)/database?...
dsn = ""
# Optimized for single-node with multiple TiDB servers
connection_pool = 32
max_idle_conns = 16
max_open_conns = 96
conn_max_lifetime = "4h"

[cardano]
# Path to Cardano node socket
node_socket = "/opt/cardano/cnode/sockets/node.socket"
# Network magic: 764824073 (mainnet), 1097911063 (testnet), 1 (preprod), 2 (preview)
network_magic = 764824073
# Protocol mode: "auto", "node-to-node", "node-to-client"
protocol_mode = "auto"

[cardano.rewards]
# Reward calculation parameters
treasury_tax = 0.20
monetary_expansion = 0.003
optimal_pool_count = 500

[performance]
# Number of parallel workers for block processing
# Optimized for AMD Ryzen 9 7950X3D (32 threads)
worker_count = 24
# Enable bulk sync mode for faster initial sync
bulk_mode_enabled = true
# Number of blocks to fetch in bulk mode
bulk_fetch_range_size = 5000
# Statistics update interval
stats_interval = "3s"
# Timeout for block fetch operations
blockfetch_timeout = "30s"
# Size of the block processing queue
block_queue_size = 50000

[dashboard]
# Enable dashboard display
enabled = true
# Dashboard type: "terminal", "web", "both", "none"
type = "terminal"
# Web dashboard port (if type is "web" or "both")
web_port = 8080
# Show detailed logs in dashboard
detailed_log = false

[monitoring]
# Enable Prometheus metrics
metrics_enabled = true
# Metrics server port
metrics_port = 9090
# Log level: "debug", "info", "warn", "error"
log_level = "info"
# Log format: "json", "text"
log_format = "json"

[metadata]
# Enable off-chain metadata fetching
enabled = true
# Number of metadata fetcher workers
worker_count = 4
# Metadata queue size
queue_size = 1000
# Rate limit (requests per second)
rate_limit = 10
# Maximum retries for failed requests
max_retries = 3
# User agent for metadata requests
user_agent = "Nectar/1.0"

[state_query]
# Enable state query service for rewards calculation
enabled = true
# Socket path (uses cardano.node_socket if empty)
socket_path = ""
`
}

// MigrateFromEnv creates a config file from current environment variables
func MigrateFromEnv(configPath string) error {
	cfg, err := Load("") // Load with env vars only
	if err != nil {
		return fmt.Errorf("failed to load environment config: %w", err)
	}

	// Marshal to TOML
	data, err := Marshal(cfg)
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}

	// Write to file
	if err := os.WriteFile(configPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	fmt.Printf("Configuration migrated from environment to: %s\n", configPath)
	return nil
}